<html>
    <head>
        <link rel="import" href="pmc-constants.html">
        <link rel="import" href="pmc-wait-dialog.html">
    </head>
    <script>

        function showWaitDialog() {
            if (_waitDialog == null) {
                _waitDialog = document.createElement("pmc-wait-dialog");
                document.body.appendChild(_waitDialog);
            }
            _waitDialog.showModal();
        }

        function closeWaitDialog() {
            if (_waitDialog != null) {
                _waitDialog.close();
            }
        }

        function inchesToPixels(inches) {
            return INCHES_TO_PX * inches;
        } 

        function cubicleUnitsToPixels(units) {
            return CU_UNITS_TO_INCHES * INCHES_TO_PX * units;
        } 

        function loadIntoPlant(pgName) {
            var allPMCDataJSon = {};
            $.each(parent._allPMCComponents, function (i, pmcComp) {
                allPMCDataJSon[pmcComp[0].id] = pmcComp[0].getValue();
            });
            $.ajax({
                type: "post",
                url: "/updateplant",
                data: {
                    token: parent._currentToken,
                    tid: parent._remoteServerTid,
                    pageName: pgName,
                    variables: JSON.stringify(allPMCDataJSon)
                },
                success: function (response) {
                    if (response == "ok") {
                        alert("Values updated successfully!");
                        var pmcComp;
                        //The same id can be used to store multiple instances
                        $.each(parent._allPMCComponents, function (i, pmcCompArray) {
                            $.each(pmcCompArray, function (j, pmcComp) {
                                pmcComp.setInitialValue(pmcComp.getValue());
                            });
                        });
                    } 
                    else {
                        alert("Form submission failed!");
                    }
                },
                error: function (response) {
                    console.log(response);
                    alert(response);
                }
            });
        }

        function getVariablesInfo(pgName, variablesNames, successFn) {
            $.ajax({
                type: "post",
                url: "/getvariablesinfo",
                data: {
                    token: parent._currentToken,
                    pageName: pgName,
                    variables: JSON.stringify(variablesNames)
                },
                success: successFn,
                error: function (response) {
                    if (waitDialog.open) {
                        waitDialog.close();
                    }
                    console.log(response);
                    alert(response);
                }
            });
        }

        function getLibraryVariablesInfo(libraryType, variablesNames, successFn) {
            $.ajax({
                type: "post",
                url: "/getlibraryvariablesinfo",
                data: {
                    token: parent._currentToken,
                    libraryType: libraryType,
                    variables: JSON.stringify(variablesNames)
                },
                success: successFn,
                error: function (response) {
                    if (waitDialog.open) {
                        waitDialog.close();
                    }
                    console.log(response);
                    alert(response);
                }
            });
        }

        function populateComponentInfo(component, pvInfo, user) {
            component.setTypeValue(pvInfo.type);
            component.setReference("none");
            component.setValidations(pvInfo.validations);
            component.setPermissionGroups(pvInfo.permissions);
            component.setIsStruct(pvInfo.isStruct);
            var userAllowed = false;
            for (var g in user.groups) {
                userAllowed = pvInfo.permissions.includes(user.groups[g]); 
                if (userAllowed) {
                    break;
                }
            }
            component.setUserAllowedToWrite(userAllowed);
            //Loop through all the elements
            var keys = Object.keys(pvInfo); 
            for (var keyIdx in keys) { 
                var memberName = keys[keyIdx];
                var memberPVInfo = pvInfo[memberName];
                var memberVariableName = memberPVInfo["name"];
                if (memberVariableName === undefined) {
                    if (Array.isArray(memberPVInfo)) {
                        component[memberName] = memberPVInfo;
                    }
                }
                else {
                    component[memberName] = memberPVInfo;
                }
            }
            //Structures do not have numberOfElements nor value
            if ("numberOfElements" in pvInfo) {
                component.setNumberOfElements(pvInfo.numberOfElements);
                component.setInitialValue(pvInfo.value);
                component.setPlantValue(pvInfo.value);
                component.setValue(pvInfo.value);
            }
            if ("choices" in pvInfo) {
                component.setChoices(pvInfo.choices);
            }
            if ("library" in pvInfo) {
                component.setLibraryType(pvInfo.library.type);
                component.setLibraryMappings(pvInfo.library.mappings);
            }
            component.infoLoaded();
        }

        function displayPlant() {
            $.each(parent._allPMCComponents, function (i, pmcCompArray) {
                $.each(pmcCompArray, function (j, pmcComp) {
                    pmcComp.setReadOnly(true);
                    var value = pmcComp.getPlantValue();
                    if (value !== undefined) {
                        pmcComp.setValue(value, false);
                    }
                });
            });
        }
        
        function setReference(currentReference) {
            if (currentReference === NONE_NAME) {
                //Reset all the values to N/A
                var pmcComp;
                $.each(parent._allPMCComponents, function (i, pmcCompArray) {
                    $.each(pmcCompArray, function (j, pmcComp) {
                        pmcComp.setReferenceValue("N/A");
                        pmcComp.setReference(currentReference);
                    });
                });
            }
            else if (currentReference === PLANT_NAME) {
                //Reset all the values to N/A
                var pmcComp;
                $.each(parent._allPMCComponents, function (i, pmcCompArray) {
                    $.each(pmcCompArray, function (j, pmcComp) {
                        pmcComp.setReferenceValue(pmcComp.getPlantValue());
                        pmcComp.setReference(currentReference);
                    });
                });
            }
            else {
                $.ajax({
                    type: "post",
                    url: "/getschedulevariablesvalues",
                    data: {
                        token: parent._currentToken,
                        scheduleUID: currentReference
                    },
                    success: function (response) {
                        var variables = $.parseJSON(response);
                        var keys = Object.keys(variables);
                        for (var i in keys) { 
                            var variableName = keys[i];
                            var variableValue = variables[keys[i]];
                            var targetElements = parent._allPMCComponents[variableName];
                            if (targetElements != null) {
                                $.each(targetElements, function (i, targetElement) {
                                    targetElement.setReferenceValue(variableValue);
                                    targetElement.setReference(currentReference);
                                });
                            }
                        }
                    },
                    error: function (response) {
                        console.log(response);
                        alert(response);
                    }
                });
            }
        }

        function copyFromSchedule(schUID, resetValue, updateRemote, setReadOnly) {
            $.ajax({
                type: "post",
                url: "/getschedulevariablesvalues",
                data: {
                    token: parent._currentToken,
                    scheduleUID: schUID
                },
                success: function (response) {
                    variables = $.parseJSON(response);
                    var keys = Object.keys(variables);
                    for (var i in keys) { 
                        var variableName = keys[i];
                        var variableValue = variables[keys[i]];
                        var targetElements = parent._allPMCComponents[variableName];
                        if (targetElements != null) {
                            $.each(targetElements, function (i, targetElement) {
                                if (resetValue) {
                                    targetElement.setInitialValue(variableValue);
                                }
                                targetElement.setValue(variableValue, updateRemote);
                                targetElement.setReadOnly(setReadOnly);
                            });
                        }
                    }
                },
                error: function (response) {
                    console.log(response);
                    alert(response);
                }
            });
        }

        function commitAllChangesToSchedule() {
            $.ajax({
                type: "post",
                url: "/commitschedule",
                data: {
                    token: parent._currentToken,
                    tid: parent._remoteServerTid,
                    scheduleUID:parent._currentScheduleUID,
                    variables:JSON.stringify(parent._scheduleValuesToCommit)
                },
                success: function (response) {
                    $.each(parent._allPMCComponents, function (i, pmcCompArray) {
                        $.each(pmcCompArray, function (j, pmcComp) {
                            pmcComp.setInitialValue(pmcComp.getValue());
                        });
                    });
                }.bind(this),
                error: function (response) {
                    console.log(response);
                    alert(response);
                }.bind(this)
            });
        }

        function undoAllChangesToSchedule() {
            $.each(parent._allPMCComponents, function (i, pmcCompArray) {
                $.each(pmcCompArray, function (j, pmcComp) {
                    pmcComp.setValue(pmcComp.getInitialValue());
                });
            });
        }

        function synchroniseRemote() {
            if (parent._currentScheduleUID !== undefined) {
                var toPop = parent._valuesToSynchroniseRemote.length;
                if (toPop > 0) {
                    var variablesToSend = {};
                    //Not perfectly safe, but worst comes to the worst I send twice the same thing from time to time
                    var i = 0;
                    while (i < toPop) {
                        var valueToSynch = parent._valuesToSynchroniseRemote.shift();//not pop since we want to remove the oldest (i.e. the first) before
                        variablesToSend[valueToSynch.id] = valueToSynch.value;
                        parent._scheduleValuesToCommit[valueToSynch.id] = valueToSynch.value;
                        i++;
                    }
                    $.ajax({
                        type: "post",
                        url: "/updateschedule",
                        data: {
                            token: parent._currentToken,
                            tid: parent._remoteServerTid,
                            scheduleUID:parent._currentScheduleUID,
                            variables:JSON.stringify(variablesToSend)
                        },
                        success: function (response) {
                            setTimeout(synchroniseRemote, 2000);
                        }.bind(this),
                        error: function (response) {
                            setTimeout(synchroniseRemote, 2000);
                            console.log(response);
                            alert(response);
                        }.bind(this)
                    });
                }
            }
            setTimeout(synchroniseRemote, 2000);
        }

        function textToTypeValue(txtValue, typeValue) {
            var ret = txtValue;
            if (typeValue.startsWith("float")) {
                if(!isNaN(ret)) {
                    ret = parseFloat(ret);
                }
                else {
                    ret = undefined;
                }
            }
            else if ((typeValue.startsWith("int") || (typeValue.startsWith("uint")))) {
                if(!isNaN(ret)) {
                    ret = parseFloat(ret);
                    if(Number.isInteger(ret)) {
                        ret = parseInt(ret);
                    }
                    else {
                        ret = undefined;
                    }
                }
                else {
                    ret = undefined;
                }
            }
            return ret;
        }

        //TODO re-write this as a class, e.g. singleton
        //IMPORTANT! Remember when accessing to these global variables to prefix with parent. so that they can be accessed from an iframe
        //The thread identifier on the remote server which is sending events through the SSE. This is to avoid receiving updates from ourselves.
        var _remoteServerTid = "";
        var _valuesToSynchroniseRemote = [];
        var _scheduleValuesToCommit = {};
        //The same component id in the dictionary can be used to store multiple instances, i.e. id : []
        var _allPMCComponents = {};
        var _currentScheduleUID = undefined;
        var _currentToken = undefined;
        //This reference to the main editor can be used to listen to page events for components that e.g. do not inherit from PMCComponent
        var _pmcMainEditor = undefined;
        var _waitDialog = null;
    
        synchroniseRemote();
    </script>
</html>
