<!-- Define a new standard component for the pmc -->
<link rel="import" href="libraries.html">
<link rel="import" href="pmc-validation.html">

<script type="text/javascript">
    //Constructor
    class PMCComponent extends HTMLElement {
        constructor() {
            super();
        }

        toString () {
            var refToDisplay = this.referenceValue;
            if (this.reference === PLANT_NAME) {
                refToDisplay = this.plantValue;
            }
            return "[" + this.id + "] Current: " + this.getValue() + " Plant: " + this.getPlantValue() + " Reference: " + this.getReferenceValue() + " Initial: " + this.getInitialValue();
        }

        showValues () {
            alert(this.toString());
        }

        compareValues (value1, value2) {
            var val1 = String(value1);
            var val2 = String(value2);
            if (this.typeValue !== undefined) {
                if ((!this.library) && (this.typeValue === "float32") || (this.typeValue === "float64")) {
                        val1 = parseFloat(value1);
                        val2 = parseFloat(value2);
                }
                else if ((!this.library) && (this.typeValue.startsWith("int") || (this.typeValue.startsWith("uint")))) {
                        val1 = parseInt(value1);
                        val2 = parseInt(value2);
                }
            }
            return (val1 === val2);
        }

        compareWithReference (value, pltValue, refValue) {
            var val1 = String(value);
            var val2 = String(value);
            //If the reference value does not match the current value, change the background
            if (this.reference === PLANT_NAME) {
                val1 = pltValue;
            }
            //must be from a schedule
            else if (this.reference !== NONE_NAME) {
                val1 = refValue;
            }
            return this.compareValues(val1, val2);
        }

        
        /**
         * @brief Function called when the component is expected to refresh its contents
         * @details To be specialised by other components that want to be warned when a browser refresh has happened.
         */
        refresh () {
        }

        /**
         * @brief Function called when the component is expected to reset its view (e.g. to clear a buffer).
         */
        reset () {
        }

        getNumberOfElements () {
            return this.numberOfElements;
        }

        setNumberOfElements (numberOfElementsIn) {
            this.numberOfElements = numberOfElementsIn;
        }

        getReferenceValue () {
            return this.referenceValue;
        }

        setReferenceValue (referenceValueToSet) {
            if (referenceValueToSet !== undefined) {
                this.referenceValue = referenceValueToSet.slice(0);
                this.refresh();
            }
        }

        isLibrary () {
            return (this.getTypeValue() === "library");
        }

        setLibraryType (libraryType) {
            this.libraryType = libraryType;
        }

        getLibraryType() {
            return this.libraryType;
        }

        setLibraryMappings (libraryMappings) {
            this.libraryMappings = libraryMappings;
        }

        getLibraryMappings() {
            return this.libraryMappings;
        }

        isReadOnly() {
            return this.readOnly;
        }

        setReadOnly (isReadOnly) {
            this.readOnly = isReadOnly;
            this.refresh();
        }

        getTypeValue () {
            return this.typeValue;
        }

        setTypeValue (typeValueToSet) {
            this.typeValue = typeValueToSet;
        }

        getPlantValue () {
            return this.plantValue;
        }

        setChoices (choices) {
            this.choices = choices;
        }

        getChoices () {
            return this.choices;
        }

        setPlantValue (plantValueToSet) {
            if (plantValueToSet !==  undefined) {
                this.plantValue = plantValueToSet.slice(0);
                this.fireValueChanged("plantValue");
                this.refresh();
            }
        }

        getInitialValue () {
            return this.initValue;
        }

        setInitialValue (initialValueToSet) {
            if (initialValueToSet !== undefined) {
                if (initialValueToSet.slice !== undefined) {
                    this.initValue = initialValueToSet.slice(0);
                }
                else {
                    this.initValue = initialValueToSet;
                }
                this.fireValueChanged("initialValue");
                this.refresh();
            }
        }

        getReference () {
            return this.reference;
        }

        setReference (referenceToSet) {
            this.reference = referenceToSet;
            this.fireValueChanged("reference");
            this.refresh();
        }

        getValue () {
            return this.value;
        }

        setValue (valueToSet, updateRemote = true) {
            this.value = valueToSet;
            this.fireValueChanged("value");
            if (updateRemote) {
                this.updateRemote(valueToSet); 
            }
            this.refresh();
        }

        updateRemote (valueToUpdate) {
            var valueToUpdateR = {
                id:this.id,
                value:valueToUpdate
            }
            var othersSameId = document._frameComponents[this.id];
            var otherPMCComp;
            $.each(othersSameId, function (j, otherPMCComp) {
                otherPMCComp.setValue(valueToUpdate, false);
            });
            if (parent._currentScheduleUID !== undefined) {
                parent._valuesToSynchroniseRemote.push(valueToUpdateR);
            }
        }

        setValidations (validationsToSet) {
            this.validations = [new PMCValidationType(this)];
            for(var i in validationsToSet) {
                this.validations.push(new PMCValidationMath(validationsToSet[i]));
            }
        }

        getValidations () {
            return this.validations;
        }

        setIsStruct (struct) {
            this.struct = struct;
        }

        isStruct() {
            return this.struct;
        }

        domLoaded () {
        }

        infoLoaded() {
        }

        getTemplate() {
        }

        valueChanged(source, typeOfChange) {
        }

        fireValueChanged(typeOfChange) {
            for(var f in this.valueChangedListeners) {
                this.valueChangedListeners[f].valueChanged(this, typeOfChange);
            }
        }

        addValueChangedListener(comp) {
            this.valueChangedListeners.push(comp);
        }

        createdCallback() {
            var template = this.getTemplate();
            if (template !== undefined) {
                // import template into
                var clone = document.importNode(template.content, true);
                var root = this.createShadowRoot();
                root.appendChild(clone);
                if (this.id !== undefined) {
                    if (this.id.length > 0) {
                        //_frameComponents must be private to the iframe, otherwise there will be name clashes with the libraries variables
                        if (document._frameComponents === undefined) {
                            document._frameComponents = {};
                        }
                        if(document._frameComponents[this.id] === undefined) {
                            document._frameComponents[this.id] = [this];
                        }
                        else {
                            document._frameComponents[this.id].push(this);
                        }
                    }
                }
            }
            this.valueChangedListeners = [];
            this.permissionGroups = [];
            this.userAllowedToWrite = false;

            this.typeValue = "string";
            this.choices = [];
            this.libraryType = undefined;
            this.libraryMappings = undefined;
            this.initValue = undefined;
            this.plantValue = undefined;
            this.referenceValue = undefined;
            this.reference = NONE_NAME;
            this.numberOfElements = 0;
            this.library = undefined;
            this.validations = undefined;
            this.struct = false;
            this.readOnly = false;
        }

        setPermissionGroups (groups) {
            this.permissionGroups = groups;
        }

        isUserAllowedToWrite () {
            return this.userAllowedToWrite;
        }

        setUserAllowedToWrite(allowed) {
            this.userAllowedToWrite = allowed;
            this.refresh();
        }

        attachedCallback () {
        }

        detachedCallback () {
        }

        isPMCComponent() {
            return true;
        }
    }
</script>

