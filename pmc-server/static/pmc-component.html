<!-- Define a new standard component for the pmc -->
<link rel="import" href="libraries.html">
<script type="text/javascript">
    const PLANT_OR_REF_CHANGED_COLOR = "gray";
    const DIFF_INIT_CHANGED_COLOR = "blue";
    const STANDARD_FCOLOR = "black";
    const STANDARD_BCOLOR = "white";

    //Constructor
    function PMCComponent() {
       HTMLElement.call(this);
    }
    PMCComponent.prototype = Object.create(HTMLElement.prototype);
    PMCComponent.prototype.constructor = PMCComponent;

    //prototype functions are capable of acting on the this (i.e. they are not static functions)
    PMCComponent.prototype.currentValuesToString = function() {
        var refToDisplay = this.refvalue;
        if (this.reference === "plant") {
            refToDisplay = this.pltvalue;
        }
        return "Current: " + this.getValue() + " Plant: " + this.getPlantValue() + " Reference: " + this.getReferenceValue() + " Initial: " + this.getInitialValue();
    }

    PMCComponent.prototype.showValues = function() {
        alert(this.currentValuesToString());
    }

    PMCComponent.prototype.compareValues = function(value1, value2) {
        var val1 = String(value1);
        var val2 = String(value2);
        if ((!this.library) && (this.typevalue === "float32") || (this.typevalue === "float64")) {
                val1 = parseFloat(value1);
                val2 = parseFloat(value2);
        }
        else if ((!this.library) && (this.typevalue.startsWith("int") || (this.typevalue.startsWith("uint")))) {
                val1 = parseInt(value1);
                val2 = parseInt(value2);
        }
        return (val1 === val2);
    }

    PMCComponent.prototype.compareWithReference = function(value, pltValue, refValue) {
        var val1 = String(value);
        var val2 = String(value);
        //If the reference value does not match the current value, change the background
        if (this.reference === "plant") {
            val1 = pltValue;
        }
        //must be from a schedule
        else if (this.reference !== "none") {
            val1 = refValue;
        }
        return this.compareValues(val1, val2);
    }

    PMCComponent.prototype.checkValues = function() {
        //If the current value does not match the initial value set the font color blue
        if(!this.compareValues(this.value, this.initvalue)) {
            this.style.color = DIFF_INIT_CHANGED_COLOR;
        }
        else {
            this.style.color = STANDARD_FCOLOR;
        }

        var newBackgroundColor = STANDARD_BCOLOR;
        if (this.compareWithReference(this.value, this.pltvalue, this.refvalue)) {
            newBackgroundColor = STANDARD_BCOLOR;
        }
        else {
            newBackgroundColor = PLANT_OR_REF_CHANGED_COLOR;
        }

        this.style.backgroundColor = newBackgroundColor;
        this.title = this.currentValuesToString();
    }

    /**
     * virtual 
     * To be specialised by other components that want to be warned when a browser refresh has happened.
     */
    PMCComponent.prototype.refresh = function() {
    }

    PMCComponent.prototype.getNumberOfElements = function() {
        return this.numberOfElements;
    }

    PMCComponent.prototype.setNumberOfElements = function(numberOfElementsIn) {
        this.numberOfElements = numberOfElementsIn;
    }

    PMCComponent.prototype.getReferenceValue = function() {
        return this.refvalue;
    }

    PMCComponent.prototype.setReferenceValue = function(referenceValueToSet) {
        this.refvalue = referenceValueToSet.slice(0);
    }

    PMCComponent.prototype.isLibrary = function() {
        return this.library;
    }

    PMCComponent.prototype.setLibrary = function(isLibrary) {
        this.library = isLibrary;
    }

    PMCComponent.prototype.getTypeValue = function() {
        return this.typevalue;
    }

    PMCComponent.prototype.setTypeValue = function(typeValueToSet) {
        this.typevalue = typeValueToSet;
    }

    PMCComponent.prototype.getPlantValue = function() {
        return this.pltvalue;
    }

    PMCComponent.prototype.setPlantValue = function(plantValueToSet) {
        this.pltvalue = plantValueToSet.slice(0);
    }

    PMCComponent.prototype.getInitialValue = function() {
        return this.initvalue;
    }

    PMCComponent.prototype.setInitialValue = function(initialValueToSet) {
        this.initvalue = initialValueToSet.slice(0);
    }

    PMCComponent.prototype.getReference = function() {
        return this.reference;
    }

    PMCComponent.prototype.setReference = function(referenceToSet) {
        this.reference = referenceToSet;
    }

    PMCComponent.prototype.getValue = function() {
        return this.value;
    }

    PMCComponent.prototype.setValue = function(valueToSet) {
        this.innerHTML = valueToSet;
        this.value = valueToSet;
    }

    //The reference in use
    Object.defineProperty(PMCComponent, "reference", {
        value: "none",
        writable: true
    });


    //The type of value
    Object.defineProperty(PMCComponent, "typevalue", {
        value: "string",
        writable: true
    });

    //Initial value
    Object.defineProperty(PMCComponent, "initvalue", {
        value: "N/A",
        writable: true
    });

    //Plant value
    Object.defineProperty(PMCComponent, "pltvalue", {
        value: "N/A",
        writable: true
    });

    //Reference value
    Object.defineProperty(PMCComponent, "refvalue", {
        value: "N/A",
        writable: true
    });

    //Number of elements
    Object.defineProperty(PMCComponent, "numberOfElements", {
        value: "N/A",
        writable: true
    });

    //If true the value is a pointer to a library (e.g. a waveform name) which actually stores the values
    Object.defineProperty(PMCComponent, "library", {
        value: "N/A",
        writable: true
    });


    PMCComponent.prototype.attachedCallback = function() {
    }

    PMCComponent.prototype.detachedCallback = function() {
    }

    function extendMixin (destination, source) {
        for (var prop in source) {
            if (source.hasOwnProperty(prop)) {
                destination[prop] = source[prop];
            }
        }
    };
</script>

