<!-- Define a new standard component for the pmc -->
<link rel="import" href="libraries.html">
<script type="text/javascript">
    const PLANT_OR_REF_CHANGED_COLOR = "gray";
    const DIFF_INIT_CHANGED_COLOR = "blue";
    const STANDARD_FCOLOR = "black";
    const STANDARD_BCOLOR = "white";

    if (!document.registerElement) {
        alert("Custom elements not supported!");
    }
    else {
        var PMCInputProto = Object.create(HTMLInputElement.prototype);

        PMCInputProto.currentValuesToString = function() {
            var refToDisplay = this.schvalue;
            if (this.currentReference === "plant") {
                refToDisplay = this.pltvalue;
            }
            return "Current: " + this.value + " Plant: " + this.pltvalue + " Reference: " + this.schvalue + " Initial: " + this.initvalue;
        }

        PMCInputProto.showValues = function() {
            alert(this.currentValuesToString());
        }

        PMCInputProto.checkValues = function() {
            //If the current value does not match the initial value set the font color blue
            if(this.value !== this.initvalue) {
                this.style.color = DIFF_INIT_CHANGED_COLOR;
            }
            else {
                this.style.color = STANDARD_FCOLOR;
            }

            var newBackgroundColor = STANDARD_BCOLOR;
            var val1 = this.value;
            var val2 = this.value;
            //If the reference value does not match the current value, change the background
            if (this.currentReference === "plant") {
                if ((this.typevalue === "float32") || (this.typevalue === "float64")) {
                    val1 = parseFloat(this.pltvalue);
                    val2 = parseFloat(this.value);
                }
                else {
                    val1 = this.pltvalue;
                }
            }
            //must be from a schedule
            else if (this.currentReference !== "none") {
                if ((this.typevalue === "float32") || (this.typevalue === "float64")) {
                    val1 = parseFloat(this.schvalue);
                    val2 = parseFloat(this.value);
                }
                else {
                    val1 = this.schvalue;
                }
            }
            if (val1 === val2) {
                newBackgroundColor = STANDARD_BCOLOR;
            }
            else {
                newBackgroundColor = PLANT_OR_REF_CHANGED_COLOR;
            }

            this.style.backgroundColor = newBackgroundColor;
            this.title = this.currentValuesToString();
        }

        //The reference in use
        Object.defineProperty(PMCInputProto, "currentReference", {
            value: "none",
            writable: true
        });


        //The type of value
        Object.defineProperty(PMCInputProto, "typevalue", {
            value: "string",
            writable: true
        });

        //Initial value
        Object.defineProperty(PMCInputProto, "initvalue", {
            value: "N/A",
            writable: true
        });

        //Plant value
        Object.defineProperty(PMCInputProto, "pltvalue", {
            value: "N/A",
            writable: true
        });

        //Reference value
        Object.defineProperty(PMCInputProto, "schvalue", {
            value: "N/A",
            writable: true
        });

//This also works... i.e. register one SSE event per component... but I don't think this is efficient.
/*                PMCInputProto.createdCallback = function() {
            var thisObj = thise;
            thisObj.value = "Undefined";
            if(typeof(EventSource) !== "undefined") {
                var source = new EventSource("http://localhost:8084/BROWSE/SSE/");
                source.onmessage = function(event) {
                    //Need to do both (at least to triger the attributeChangedCallback)
                    thisObj.setAttribute("pltvalue", event.data);
                    thisObj.pltvalue = event.data; 
                };
            } else {
                this.value = "Sorry, your browser does not support server-sent events...";
            }
        }*/

        PMCInputProto.attachedCallback = function() {
        }

        PMCInputProto.detachedCallback = function() {
        }

        PMCInputProto.attributeChangedCallback = function(attrName, oldValue, newValue) {
            this.checkValues(); 
        }

        document.registerElement("pmc-input", {
            prototype: PMCInputProto,
            extends: "input"
        });
    }
</script>

